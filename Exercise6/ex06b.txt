Priority inversion occurs when a higher-priority task is forced to wait for a long (usually indefinite) period of time for the completion of a lower priority task, usually because the lower priority task has blocked a shared resource and then got preempted by an intermediate priority task.

This behaviour was simulated in ex06a with a binary semaphore. Replacing the semaphore (and all associated operations) in ex06a with a mutex will solve the priority inversion issue in the following way: it runs a priority inheritance algorithm where a task owning a resource runs at the same priority as a task which is blocked upon that mutex. Thus the lower priority task runs at the same priority as the higher priority task, not allowing the intermediate priority task to preempt the execution of the former (or, if this already happened, the originally lower priority task will get to preempt the medium priority task due to its now increased priority).